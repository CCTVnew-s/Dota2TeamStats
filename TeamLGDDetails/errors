// Expand function
expwjf:{[f;args;newname] 
         (enlist f),args, newname};

// Apply Function to Varianble in Certian Filters :    f( x ) where f1(c1), f2(c2), f3(c3)......
// Extend to further variable cases:      f(x,y)  where f1(c1), f2(c2), f3(c3)......
// So,   max you can parse [f;x;y;z;...;c1;c2;c3..;(f1;fi)]  Variable Nums + Constraints Nums <= 6
       
applyf1_1:{[f;constraints]
 :{[f;x;x1;constraints]
   loc:constraints[0][x1];
   :f[x where loc]}[f;;;constraints]
 };
applyf1_2:{[f;constraints]
:{[f;x;x1;x2;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]);
   :f[x where loc]}[f;;;;constraints]
 };
applyf1_3:{[f;constraints]
:{[f;x;x1;x2;x3 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]) and (constraints[2][x3]);
   :f[x where loc]}[f;;;;;constraints]
 };

// more 
applyf2_1:{[f;constraints]
:{[f;x;y; x1 ;constraints]
   loc:(constraints[0][x1]);
   :f[x where loc;y where loc]}[f;;;;constraints]
 };
applyf2_2:{[f;constraints]
:{[f;x;y;x1;x2 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]);
   :f[x where loc;y where loc]}[f;;;;;constraints]
 };
applyf2_3:{[f;constraints]
:{[f;x;y;x1;x2 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]) and (constraints[2][x3]);
   :f[x where loc;y where loc]}[f;;;;;;constraints]
 };
// 
applyf3_1:{[f;constraints]
:{[f;x;y;z;x1 ;constraints]
   loc:(constraints[0][x1]);
   :f[x where loc;y where loc;z where loc]}[f;;;;;constraints]
 };
applyf3_2:{[f;constraints]
:{[f;x;y;z;x1;x2 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]);
   :f[x where loc;y where loc;z where loc]}[f;;;;;;constraints]
 };
applyf3_2:{[f;constraints]
:{[f;x;y;z;x1 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]) and (constraints[2][x3]);
   :f[x where loc;y where loc;z where loc]}[f;;;;;;;constraints]
 };

applyf4_1:{[f;constraints]
:{[f;x;y;z;w;x1 ;constraints]
   loc:(constraints[0][x1]);
   :f[x where loc;y where loc;z where loc;w where loc]}[f;;;;;;constraints]
 };

applyf4_2:{[f;constraints]
:{[f;x;y;z;x1 ;constraints]
   loc:(constraints[0][x1]) and (constraints[1][x2]);
   :f[x where loc;y where loc;z where loc]}[f;;;;;;;constraints]
 };

applyf5_1:{[f;constraints]
:{[f;x;y;z;w;v;x1 ;constraints]
   loc:(constraints[0][x1]);
   :f[x where loc;y where loc;z where loc;w where loc;v where loc]}[f;;;;;;constraints]
 };



// Rest should be fine
// seems not very useful
applyf1_4:{[f;constraints]
 };
applyf1_5:{[f;constraints]
 };
applyf2_4:{[f;constraints]
 };
applyf2_5:{[f;constraints]
 };


// EXPAND THESE INTO F
applyfwjafterconstrain :{[f;applycol;filtercol;constraints;newname]
n:count applycol;
m:count filtercol;
if[(n=1)and(m=1);
:(enlist {[f;x;x1;name]f[x;x1]}[applyf1_1[f;constraints];;;]),applycol,filtercol,enlist newname;
];
if[(n=1)and(m=2);
:(enlist {[f;x;x1;x2;name]f[x;x1;x2]}[applyf1_2[f;constraints];;;;]),applycol,filtercol,enlist newname;
];
if[(n=1)and(m=3);
:(enlist {[f;x;x1;x2;x3;name]f[x;x1;x2;x3]}[applyf1_3[f;constraints];;;;;]),applycol,filtercol,enlist newname;
];
if[(n=1)and(m=4);
:(enlist {[f;x;x1;x2;x3;x4;name]f[x;x1;x2;x3;x4]}[applyf1_4[f;constraints];;;;;;]),applycol,filtercol,enlist newname;
];
if[(n=2)and(m=1);
:(enlist {[f;x;y;x1;name]f[x;y;x1]}[applyf2_1[f;constraints];;;;]),applycol,filtercol,enlist newname;
];
if[(n=2)and(m=2);
:(enlist {[f;x;y;x1;x2;name]f[x;y;x1;x2]}[applyf2_2[f;constraints];;;;;]),applycol,filtercol,enlist newname;
];
if[(n=2)and(m=3);
:(enlist {[f;x;y;x1;x2;x3;name]f[x;y;x1;x2;x3]}[applyf2_3[f;constraints];;;;;;]),applycol,filtercol,enlist newname;
];
if[(n=3)and(m=1);
:(enlist {[f;x;y;z;x1;name]f[x;y;z;x1]}[applyf3_1[f;constraints];;;;;]),applycol,filtercol,enlist newname;
];
if[(n=3)and(m=2);
:(enlist {[f;x;y;z;x1;x2;name]f[x;y;z;x1;x2]}[applyf3_2[f;constraints];;;;;;]),applycol,filtercol,enlist newname;
];
if[(n=4)and(m=1);
:(enlist {[f;x;y;z;u;x1;name]f[x;y;z;u;x1]}[applyf4_1[f;constraints];;;;;;]),applycol,filtercol,enlist newname;
];
if[(n=4)and(m=2);
:(enlist {[f;x;y;z;u;x1;x2;name]f[x;y;z;u;x1;x2]}[applyf4_2[f;constraints];;;;;;;]),applycol,filtercol,enlist newname;
];
if[(n=5)and(m=1);
:(enlist {[f;x;y;z;u;v;x1;name]f[x;y;z;u;v;x1]}[applyf5_1[f;constraints];;;;;;;]),applycol,filtercol,enlist newname;
];
:`;
};

// make up table --- Calc table  ----  WJWindow; Calc; Nameconventions; ApplyTable ?
//   | TableName; WJwindow;  FeaturePrefix ; ApplyFunction And Args[ FeatureName ] |  --- this should be 1 row
//  Eventually new FeatureName will be  WJNum + FeaturePrefix + FeatureName

process1win: {[tgtx;infotable;iter;iteritem]
  w: iteritem`win;       
  : delete time from wj1[ $[w=0W; ((count tgtx)#0t;tgtx`time); (tgtx`time) +/: (neg w; 0) * 60 * 1000];
      `time; tgtx; (enlist infotable), first value iter[iteritem]]
};

process1table: {[tgtx;tablesource;iter; iterkey; tableid]
    winstoprocess: select from iterkey where table = tableid;
    :{x,'y} over process1win[tgtx;tablesource[tableid];iter;] each winstoprocess
};

wjtable:wjtables
ApplyWJTable:{[tgtx;tablesource;wjtable]
 nameprefix: (?[0W = wjtable`win; (count wjtable)#enlist "wall"; "w",/:  string  wjtable`win]),' string wjtable`prefix;
 wjtable: 
 wjtable: update prefix: nameprefix, funele:   { { (-1 _ x), `$ y, (string last x) }'[x;y]  }[funele; nameprefix]     from wjtable;
 iter: select funele by table, win from wjtable;
 iterkey: `table`win xasc key iter;
 itertables: exec distinct table from iterkey;
 :{x,'y} over (enlist tgtx), process1table[select time from tgtx;tablesource;iter; iterkey; ] each itertables ;
};



sameric: { `$@[string x;til 6]};

readdaily:{
dailysource: system "ls /data2/dailydata";
rtn: (),/ { ("ISDFFFFFFFFFF";enlist ",") 0: `$":/data2/dailydata/",x} each dailysource;
:rtn};
dailydata: readdaily[];
dailydata: update sym: sameric each ts_code from dailydata;

crmpath: `:/data2/crmmap.csv;
crmmap:("SS";enlist ",") 0:crmpath;

Qcrms: `C30572`C31448`C32042`C32172`C35766`C35831`C35848`C36022`C36146`C36379`C36384`C36477`C36580`C36627`C36835`C37198`C37208`C37434`C37435`C37512`C37666`C37667`C37669`C37849`C37858`C37859`C40120`C42839`C43244;
l1crm: `C35831`C31448`C35766;
l2crm: `C43244`C32042;
l3crm: `C30572`C36835`C36022`C35848`C36477`C37849`C37669`C37512`C36580;
accountmap:()!();
accountmap[`tier1]: l1crm;
accountmap[`tier2]: l2crm;
accountmap[`tier3]: l3crm;
accountmap[`otherQ]: Qcrms where not Qcrms in l1crm,l2crm,l3crm;
reverseaccountmap: (()!()) ,/ {[k;m] m[k]!(count m[k])#k}[;accountmap] each key accountmap;


files:  "/data2/cdata2copy";

gettgt:{[p]
    files: system "ls ",p;
    files: distinct ssr[;"#";""] each files;
    :files;
 };

tgt: gettgt[files];

f:tgt[600]

getdata: {[f;files]
       0N!f;
       datax: get `$ ":", files,"/",f;
       o1: datax[0];
       o2: datax[1];
       e1: datax[2];
       extrao: datax[6];
       hpro: datax[7];
       hpre: datax[8];
        :(o1;o2;e1;hpro;hpre;extrao);
  };

alldata: getdata each tgt;



uniricmap: {x ! sameric each x} ;
mapd: {x ! sameric each x} distinct (exec distinct RIC from o1),(exec distinct RIC from hpro);

o1: update sym: mapd RIC, Side: ?[Side="1";`b;`s], accategory: `other ^ reverseaccountmap Account from o1;
hpro: update sym:mapd RIC, Side: ?[Side="1";`b;`s], accategory: `other ^ reverseaccountmap Account from hpro;
hpre: hpre lj `OrderId xkey select OrderId, Account, accategory, Account, Side, sym from hpro;




r1: select OrderId, RootId: OrderId, nextParent: -1 , level:0 from o1;
r2: select OrderId, RootId: OrderId, nextParent: ParentId, level:1 from o2;
parentrela: (exec OrderId!ParentId from o1), (exec OrderId!ParentId from o2);
while[ not 0 = exec sum nextParent <> -1 from r2 ;
r2: update RootId: parentrela RootId, nextParent: parentrela nextParent,level: level + 1 from r2 where not nextParent = -1;
];
o2: o2 lj `OrderId xkey select OrderId, RootId, level from r2;
o2: o2 lj `RootId xkey select RootId:OrderId, sym, Side, StratType, Account,accategory from o1;
e1: e1 lj `OrderId xkey select sym, Account,accategory, Side, StratType, RootId, OrderId from o2;
e1: e1 lj `OrderId xkey select sym, Account,accategory, Side, StratType, RootId:OrderId, OrderId from o1;

tgtcrm: `C35831`C31448;
tgtframe: (select sym: mapd RIC,`time$time, Side, Account, OrderId, Price, Quantity from o1 where Account in tgtcrm, event=`Pending), (select sym: mapd RIC,`time$time, Side, Account,OrderId, Price, Quantity from hpro where Account in tgtcrm, event=`Pending);

symall: exec distinct sym from tgtframe;
symx:symall[0]






onesym: {[o1;o2;e1;hpro;hpre;tgtframe;wjtables;symx]
0N!symx;
o1x: (select time, Account,accategory, event, OrderId, Price, Quantity, Side, StratType, OrigGroup, Destination: VirtualDestination from o1 where sym = symx, not VirtualDestination = `CROSS, not Account in tgtcrm),(select time, Account,accategory, event, OrderId , Price, Quantity, Side, StratType:12h, OrigGroup:`HPR, Destination:`HPR from hpro where  sym = symx, not Account in tgtcrm) ;
o1x: update axis:`Parent, RootId: OrderId, activeQty: ?[event=`PendingCancel;0;Quantity] from o1x;
o1mchild: select time, Account,accategory, event, OrderId, Price, Quantity, Side,StratType:0Nh, OrigGroup:`, axis:`Child, RootId,Destination: VirtualDestination  from o2 where sym = symx, not Account in tgtcrm, VirtualDestination like "*M*";
o1exec:   (select time, Account,accategory, event, OrderId, Price, Quantity, Side,StratType:0Nh, OrigGroup:`, axis:`Child, RootId,Destination from e1 where sym = symx, not Account in tgtcrm, event = `Executed), (select time, Account,accategory, event:`Executed, OrderId, Price, Quantity, Side,StratType:12h, OrigGroup:`, axis:`Child,RootId: OrderId ,Destination:`HPR from hpre where sym = symx);
o1child: o1mchild, o1exec;
oall: `time xasc o1x, update activeQty: 0Nj from o1child;
oall: update time:`time$time, cumQty: sums ?[event=`Executed;Quantity;0], fills activeQty, fills StratType, fills OrigGroup by RootId from oall;
oall: delete from oall where Destination = `CROSS, null activeQty;
tgtx: select from tgtframe where sym = symx;
tablesource:`all`executed!(oall;select from oall where event = `Executed);
:ApplyWJTable[tgtx;tablesource;wjtables]};


accountsidestats:{[sidecol;accol;tgtside]
            if[0 = count sidecol;:0i]; 
            sum value  {[x;y] y ~ asc distinct x}[; tgtside] each sidecol group accol};



getExecAcgroupBasicFeature1:{[acgroup;wjwins;prefix]
   idfun : {[x;y] x=y}[;acgroup];
   funcs: (enlist applyfwjafterconstrain[sum;enlist `Quantity; `accategory`Side; (idfun ;{x=`b});`sumb]),
          (enlist applyfwjafterconstrain[sum;enlist `Quantity; `accategory`Side; (idfun ;{x=`s});`sums]),
          (enlist applyfwjafterconstrain[{?[0<count x;x wavg y;0nf]}; `Quantity`Price; `accategory`Side; (idfun ;{x=`b});`avgpxb]),
          (enlist applyfwjafterconstrain[{?[0<count x;x wavg y;0nf]}; `Quantity`Price; `accategory`Side; (idfun ;{x=`s});`avgpxs]),
          (enlist applyfwjafterconstrain[{?[0<count x;min x;0nf]};enlist `Price; `accategory`Side; (idfun ;{x=`b});`minpxb]),
          (enlist applyfwjafterconstrain[{?[0<count x;min x;0nf]};enlist `Price; `accategory`Side; (idfun ;{x=`s});`minpxs]),
          (enlist applyfwjafterconstrain[{?[0<count x;max x;0nf]};enlist `Price; `accategory`Side; (idfun ;{x=`b});`maxpxb]),
          (enlist applyfwjafterconstrain[{?[0<count x;max x;0nf]};enlist `Price; `accategory`Side; (idfun ;{x=`s});`maxpxs]),
          (enlist applyfwjafterconstrain[{?[0<count x;last x;`]};enlist `Side; enlist `accategory; (enlist idfun );`lastsd]),
          (enlist applyfwjafterconstrain[{?[0<count x;last x;0nf]};enlist `Price; enlist `accategory; (enlist idfun );`lastpx]); 
 : {`table`win`prefix`funele!x} each raze (`executed,/: wjwins,'prefix) ,/:\: enlist each funcs ;};


getExecAcgroupBasicFeature2:{[acgroup;wjwins;prefix]
   idfun : {[x;y] x=y}[;acgroup];
   funcs: (enlist applyfwjafterconstrain[{?[0<count x; count distinct x;0]};enlist `Account; `accategory`Side; (idfun ;{x=`b});`nbac]),
          (enlist applyfwjafterconstrain[{?[0<count x; count distinct x;0]};enlist `Account; `accategory`Side; (idfun ;{x=`s});`nsac]);
 : {`table`win`prefix`funele!x} each raze (`executed,/: wjwins,'prefix) ,/:\: enlist each funcs ;};


priceqtl:{[price;qty;splitN]
            qtyqtl: (1 + til splitN - 1) * (1.0%splitN) *  sum qty;
            sortqty: qty iasc price;
            reverse 1 _ fills reverse value (til splitN )#max each (asc price) group sum each (sums sortqty) >\: qtyqtl};

// Qtls 
getExecQtlsQuantNonQuant:{[wjwins;prefix]
   funcs: (enlist applyfwjafterconstrain[{?[0<count x;priceqtl[x;y;5];5#0nf]};`Price`Quantity; `accategory`Side; ({not x = `other} ;{x=`b});`QtBqtls]),
          (enlist applyfwjafterconstrain[{?[0<count x;priceqtl[x;y;5];5#0nf]};`Price`Quantity; `accategory`Side; ({not x = `other} ;{x=`s});`QtSqtls]),
          (enlist applyfwjafterconstrain[{?[0<count x;priceqtl[x;y;5];5#0nf]};`Price`Quantity; `accategory`Side; ({x = `other} ;{x=`b});`nQtBqtls]),
          (enlist applyfwjafterconstrain[{?[0<count x;priceqtl[x;y;5];5#0nf]};`Price`Quantity; `accategory`Side; ({x = `other} ;{x=`s});`nQtSqtls]);
   : {`table`win`prefix`funele!x} each raze (`executed,/: wjwins,'prefix) ,/:\: enlist each funcs ;};


// 

sumActive:{[RootId;activeQty;cumQty]
if[0=count RootId;:0];
:{sum ?[x>0;x;0]} value last each (activeQty - cumQty) group RootId;};

getActiveFutureQty:{
      funcs: (enlist applyfwjafterconstrain[sumActive ;`RootId`activeQty`cumQty; `accategory`Side; ({x = `other} ;{x=`b});`bfutqty]),
          (enlist applyfwjafterconstrain[sumActive ;`RootId`activeQty`cumQty; `accategory`Side; ({x = `other} ;{x=`s});`sfutqty]);
       {`table`win`prefix`funele!x} each (`all; 0W;`) ,/: enlist each funcs };


oall


symall



wjtables: getExecAcgroupBasicFeature1[`tier1;(20;40;60;0W);`tier1], 
          getExecAcgroupBasicFeature1[`tier2;(20;40;60;0W);`tier2], 
          getExecAcgroupBasicFeature1[`tier3;(20;40;60;0W);`tier3], getExecAcgroupBasicFeature2[`tier3;(20;40;60;0W);`tier3],
          getExecAcgroupBasicFeature1[`otherQ;(20;40;60;0W);`otherQ], getExecAcgroupBasicFeature2[`otherQ;(20;40;60;0W);`otherQ],
          getExecAcgroupBasicFeature1[`other;(20;40;60;0W);`other], getExecAcgroupBasicFeature2[`other;(20;40;60;0W);`other],
          getExecQtlsQuantNonQuant[(20;40;60;0W);`],
          getActiveFutureQty[],


rtn : onesym[o1;o2;e1;hpro;hpre;tgtframe;wjtables;] peach symall


rtn: (),/ rtn

rtn: update d






